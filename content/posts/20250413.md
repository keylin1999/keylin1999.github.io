+++
title = 'C++ èªæ³•'
date = 2025-04-13T21:05:56+08:00
draft = false

+++



è¨˜å¾—å‰›ç•¢æ¥­çš„æ™‚å€™é¢è©¦ nvidia é¢è©¦å®˜å•äº†å¾ˆå¤šé—œæ–¼ C++ çš„æ±è¥¿ï¼Œç„¶å¾Œå…¶ä¸­ä¸€å€‹é¡Œç›®æ˜¯å¸Œæœ›ç¾å ´å¯«ä¸€å€‹çŸ©é™£çš„ classï¼Œé‚£æ™‚å€™æˆ‘ç­”å¾—ä¸å¤ªå¥½ï¼Œé¢è©¦å®˜åœ¨æˆ‘å¯«çš„éç¨‹ä¸­å¹«æˆ‘åšä¸€äº›ä¿®æ”¹æœ€å¾Œæ‰å‹•èµ·ä¾†ã€‚é›–ç„¶åªæ˜¯ä¸€äº›èªæ³•ä¸Šçš„å•é¡Œï¼Œä½†å…¶å¯¦å°±é¡¯ç¾å‡ºæˆ‘å…¶å¯¦å° C++ ä¸¦æ²’æœ‰çœŸçš„åˆ°å¾ˆç†Ÿã€‚

å¾Œä¾†æˆ‘ç¾å ´å¯«é¡Œç›®çš„ç’°ç¯€æœ‰ç­”å°ï¼Œä½†æœ‰å¹¾é¡Œæ²’æœ‰æƒ³åˆ°æœ€ä½³è§£æ‰€ä»¥æœ€å¾Œæ”¶äº†æ‹’çµ•ä¿¡ã€‚ç¾åœ¨æˆ‘å·²ç¶“å·¥ä½œä¸€é™£å­äº†ï¼Œæ˜¯æ™‚å€™å›éé ­ä¾†ç³»çµ±åœ°å¾©ç¿’é€™äº›èªæ³•çŸ¥è­˜ï¼Œä¸¦é€šéåˆ·é¡Œä¾†éå›ºåŸºç¤ï¼ŒåŒæ™‚ç‚ºæ¥ä¸‹ä¾†å…¶ä»–å…¬å¸çš„é¢è©¦æå‰åšå¥½å‡†å‚™ã€‚

æ¥ä¸‹ä¾†é è¨ˆé€²è¡Œä»¥ä¸‹å¹¾å€‹éšæ®µçš„ C++ è¤‡ç¿’èˆ‡å­¸ç¿’ï¼š

1. å¿«é€Ÿè¤‡ç¿’ C++ class èªæ³•
2. æ·±å…¥å­¸ç¿’ modern C++
3. linking ç›¸é—œæ¦‚å¿µ

é€™ç¯‡ç­†è¨˜å°‡æœƒè¨˜éŒ„ï¼š
- C++ ä¸­ class çš„èªæ³•çµæ§‹
- ç¹¼æ‰¿ï¼ˆInheritanceï¼‰èˆ‡å¤šå‹ï¼ˆPolymorphismï¼‰æ©Ÿåˆ¶
- Copy Constructor èˆ‡ Copy Assignment çš„å¯«æ³•èˆ‡ä½¿ç”¨ç¯„ä¾‹

## Class Syntax

header file

```C++
// file
class Polygon {
// protected: åªæœ‰ extended class å¯ä»¥ access
private:
  int sides;

public:
  // Constructor
  Polygon(const int sides);
  
  // Destructor
  ~Polygon();
    
  // Getter and setter
  int GetSides() const; // const indicate that this do not modify the class
  void SetSides(const int sides); // using const guarantee you do not modify the value
}; // semicolon required
```

class definition

```C++
#include "polygon.h"

Polygon::Polygon(const int sides) {
  this->sides = sides
}

// can also be written in
// Polygon::Polygon(const int sides): sides(sides) {}
// this is called Member Initializer Lists
// æœƒéœ€è¦é€™æ¨£å¯«æ˜¯å› ç‚ºå¦‚æœ sides åœ¨ class è£¡é¢æ˜¯ const intï¼Œé‚£ä½ å…¶å¯¦æ˜¯
// ä¸èƒ½åœ¨ constructor è£¡é¢å»æ”¹ä»–çš„ï¼Œæ‰€ä»¥è¦ç”¨ä¸Šé¢çš„é€™ç¨®å¯«æ³•æ¯”è¼ƒå¥½ï¼Œé‚„æœ‰ä¸€ç¨®æƒ…æ³
// æ˜¯ reference of intï¼Œå› ç‚ºä»–ä¸èƒ½æ˜¯ "null" æˆ– "uninitialized" 
// class Polygon {
//   const int sides;      // const: must be initialized
//   int& someRef;         // references: must be initialized
// public:
//   Polygon(int s, int& ref) : sides(s), someRef(ref) {}
// };
```

## Inheritance

å‡è¨­æˆ‘å€‘è¦å¯«ä¸€å€‹ rectangle ç„¶å¾ŒæŠŠ Polygon çš„ attribute inherit ä¸‹ä¾†

```C++
// rectangle.h
// é€™è£¡çš„ public æŒ‡çš„æ˜¯å¦‚æœæœ‰äºº new å‡ºä¸€å€‹ Rectangle çš„ instanceï¼Œä»–å° Polygon çš„æ–¹æ³•è·Ÿå±¬æ€§çš„ visibility æ˜¯ä»€éº¼ï¼Œæ‰€ä»¥å¦‚æœæ˜¯ privateï¼Œåˆ¥äººå°±ä¸èƒ½ç”¨ rectangle.GetSides()ï¼Œä¸å¯«çš„è©± default æ˜¯ private (class)ï¼Œç„¶å¾Œ struct å°±æœƒæ˜¯ public
// Public inheritance is by far the most common type of inheritance
class Rectangle : public Polygon {
private:
  int length
  int width
    
public:
    explicit Rectangle(const std::string &name);
    Rectangle(const std::string &name, const int length, const int width);

    // Getters and Setters
    const int GetLength(void) const { return this->length; }
    void SetLength(const int) { this->length = length; }

    const int GetWidth(void) const { return this->width; }
    void SetWidth(const int) { this->width = width; }
  
    const int Area(void) const;
}
```

explicit åªæœ‰åœ¨ä¸€å€‹ parameter çš„ class constructor éœ€è¦ç”¨åˆ°ï¼Œæœƒéœ€è¦çš„åŸå› æ˜¯å› ç‚ºä¸‹é¢çš„é€™å€‹ç¨‹å¼ç¢¼æ˜¯æœƒç·¨è­¯éçš„

```C++
class Rectangle {
public:
    Rectangle(const std::string& name) { /* ... */ }
};

void printRectangle(const Rectangle& r) {
    // ...
}

int main() {
    printRectangle("MyRect");  // â—This compiles! Implicitly converts string â†’ Rectangle
}
```

é€™å€‹å« implicit conversionï¼ŒåŠ äº† explicit å°±ä¸èƒ½é€™æ¨£åšäº†ã€‚

## Class Polymorphism

ç”¨ virtual ä¾†å®šç¾©éœ€è¦è¢«å¯¦ä½œçš„ interfaceï¼Œæ‰€ä»¥åœ¨ runtime çš„æ™‚å€™è¢« call çš„ function å°±æœƒä¾é‚£å€‹ class ä¾†åš

```C++
#include <cmath>

class Shape {
public:
    // Virtual destructor (VERY IMPORTANT, SEE NOTE BELOW)
    virtual ~Shape() {}

    // Virtual area method
    virtual double Area() const {
        return 0.0;
    }
  	// ç”¨ virtual double Area() const = 0 ä¾†å¼·åˆ¶å­
};

class Rectangle : public Shape {
private:
    double length;
    double width;

public:
    Rectangle(double w, double l) : width(w), length(l) {}

    // Override the Shape::Area() method with an implementation specific to Rectangle
    double Area() const override {
        return length * width;
    }
};

class Circle : public Shape {
private:
    double radius;

public:
    explicit Circle(double t) : radius(r) {}

    // Override the Shape::Area() method with an implementation specific to Circle
    //
    // NOTE: there is an 'override' keyword that was introduced in C++11 and is optional: it is used
    // to enforce that the method is indeed an overriding method of a virtual base method at compile time
    // and is used as follows:
    double Area() const override {
        return M_PI * radius * radius; // pi*r^2
    }
};
```

ç‚ºä»€éº¼ä¸€å®šè¦ç”¨ virtual ä¾†å¯¦ç¾å¤šå‹ï¼Œå‡è¨­ä»¥ä¸‹ exampleï¼Œå› ç‚ºæˆ‘å€‘å‡è¨­ a çš„ type æ˜¯ Animalï¼Œæ‰€ä»¥æœ€å¾Œä»– call çš„ function é‚„æ˜¯ Animal çš„å¯¦ä½œ:

```C++
#include <iostream>
using namespace std;

class Animal {
public:
    void speak() {  // ğŸ‘ˆ NOT virtual
        cout << "Animal speaks" << endl;
    }
};

class Dog : public Animal {
public:
    void speak() {  // This is not overriding in a polymorphic sense
        cout << "Dog barks" << endl;
    }
};

int main() {
    Animal* a = new Dog();
    a->speak();  // â— Calls Animal::speak â€” NOT Dog::speak
}
```



**æœ‰ virtual method ä¸€å®šè¦æœ‰ä¸€å€‹ virtual destructor**

ç‚ºä»€éº¼ï¼Ÿ

```C++
class Base {
public:
    ~Base() {
        std::cout << "Base destructor\n";
    }
};

class Derived : public Base {
public:
    ~Derived() {
        std::cout << "Derived destructor\n";
    }
};

int main() {
    Base* ptr = new Derived();
    delete ptr;  // âŒ Only Base's destructor is called!
}

```

è§£æ³•å°±æ˜¯åƒä¸Šé¢ä¸€æ¨£åŠ  virtual destructor

```C++
class Base {
public:
    virtual ~Base() {
        std::cout << "Base destructor\n";
    }
};

class Derived : public Base {
public:
    ~Derived() {
        std::cout << "Derived destructor\n";
    }
};

```

> If your class has **any virtual functions**, you should almost certainly make the destructor **virtual** too.

Otherwise, you risk memory/resource leaks when deleting derived objects via base pointers.





## å…¶ä»–èªæ³•

* explicitï¼ˆå‰é¢æéï¼‰
* Member Initializer Listsï¼ˆå‰é¢æéï¼‰

### Copy Constructor and Copy Assignment

```C++
Foo a(10);
Foo b(a);   // (1): Copy via constructor
Foo c ;
c = a;	// (2): Copy via assignment operator
```

Copy Constructor å¯«æ³•

```C++
class Foo {
private:
    int data;

public:
    // Default (no argument) constructor
    Foo() : data(0) {}

    // Single argument constructor
    explicit Foo(const int v) : data(v) {}

    // Copy constructor
    Foo(const Foo & f) : data(f.data) {}

    // Copy assignment operator
    Foo & operator=(const Foo & f) {
        data = f.data;
        return *this;
    }
};
```

é™„ä¸Šä¸€å¼µæ¯”è¼ƒè¡¨

| Feature          | Copy Constructor                              | Copy Assignment Operator                             |
| ---------------- | --------------------------------------------- | ---------------------------------------------------- |
| Purpose          | Create a new object as a copy of another      | Assign values to an existing object from another     |
| Syntax           | `ClassName(const ClassName& other)`           | `ClassName& operator=(const ClassName& other)`       |
| When called?     | When a new object is initialized with another | When an existing object is assigned anotherâ€™s values |
| Default behavior | Member-wise copy                              | Member-wise copy                                     |

